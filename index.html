<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="color-scheme" content="dark light" />
		<link rel="stylesheet" href="./css/styles.css" media="screen" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>WebGL Logo</title>
		<script src="js/twgl-full.js"></script>
		<script
			id="basic-vert"
			src="js/shaders/basic.vert"
			type="notjs"
		></script>
		<script
			id="shape-frag"
			src="js/shaders/shape.glsl"
			type="notjs"
		></script>
		<script
			id="merge-frag"
			src="js/shaders/merge.glsl"
			type="notjs"
		></script>
		<script
			id="color-frag"
			src="js/shaders/color.glsl"
			type="notjs"
		></script>
		<script
			id="texture-frag"
			src="js/shaders/texture.glsl"
			type="notjs"
		></script>
	</head>
	<body>
		<canvas id="c"></canvas>
		<script type="module">
			// Load shaders
			const shaders = [
				...document.querySelectorAll('[src][type="notjs"]'),
			];

			// TODO(bret): cache the shaders

			const loadShader = async (src) => {
				return fetch(src)
					.then((res) => res.text())
					.then(async (text) => {
						const regex = /#include "(?<fileName>[\w\/\.\-\_]+)"/g;

						const matches = text.matchAll(regex);

						const replacements = await Promise.all(
							matches.map((match) => {
								const { fileName } = match.groups;
								// TODO(bret): this hack is gonna break at some point probably
								return loadShader(src + '/../' + fileName).then(
									(content) => [fileName, content],
								);
							}),
						);

						let finalText = text;
						replacements.forEach(([fileName, content]) => {
							finalText = finalText.replace(
								`#include "${fileName}"`,
								content,
							);
						});

						return finalText;
					});
			};

			const promises = shaders.map(async (shader) => {
				shader.text = await loadShader(shader.src);
			});
			await Promise.all(promises);

			// Init WebGL/TWGL
			twgl.setDefaults({ attribPrefix: 'a_' });
			const gl = document.getElementById('c').getContext('webgl2');

			const createFragShader = (frag) => {
				return twgl.createProgramInfo(gl, ['basic-vert', frag]);
			};

			const shapeProgram = createFragShader('shape-frag');
			const mergeProgram = createFragShader('merge-frag');
			const colorProgram = createFragShader('color-frag');
			const textureProgram = createFragShader('texture-frag');

			const fbis = Array.from({ length: 5 }, () =>
				twgl.createFramebufferInfo(gl),
			);
			const [fbiTemp, fbiA, fbiB, fbiC, fbiD] = fbis;

			const arrays = {
				position: [
					[-1, -1, 0],
					[1, -1, 0],
					[-1, 1, 0],
					[-1, 1, 0],
					[1, -1, 0],
					[1, 1, 0],
				].flat(),
			};
			const bufferInfo = twgl.createBufferInfoFromArrays(gl, arrays);

			const SHAPE = {
				CIRCLE: 0,
				BOX: 1,
			};
			const shapes = [
				{
					shape: SHAPE.CIRCLE,
					size: [0.2, 0.2],
				},
				{
					shape: SHAPE.BOX,
					size: [0.1, 0.3],
				},
				{
					shape: SHAPE.CIRCLE,
					pos: [0.15, 0.35],
					size: [0.1, 0.1],
				},
				{
					shape: SHAPE.CIRCLE,
					pos: [-0.15, -0.35],
					size: [0.1, 0.1],
				},
			];

			const clearBuffer = (fbi) => {
				gl.bindFramebuffer(gl.FRAMEBUFFER, fbi.framebuffer);
				gl.clearColor(0, 0, 0, 0);
				gl.clear(gl.COLOR_BUFFER_BIT);
				gl.bindFramebuffer(gl.FRAMEBUFFER, null);
			};

			function render(time) {
				twgl.resizeCanvasToDisplaySize(gl.canvas);
				const resolution = [gl.canvas.width, gl.canvas.height];
				gl.viewport(0, 0, ...resolution);

				const resizeArgs = [undefined, ...resolution];
				fbis.forEach((fbi) => {
					twgl.resizeFramebufferInfo(gl, fbi, ...resizeArgs);
				});

				gl.enable(gl.BLEND);
				gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

				const commonUniforms = {
					// u_time: time * 0.001,
					u_resolution: resolution,
				};

				const draw = (programInfo, fbi = null, uniforms = {}) => {
					twgl.bindFramebufferInfo(gl, fbi);
					gl.useProgram(programInfo.program);
					twgl.setBuffersAndAttributes(gl, programInfo, bufferInfo);
					twgl.setUniforms(programInfo, {
						...commonUniforms,
						...uniforms,
					});
					twgl.drawBufferInfo(gl, bufferInfo);
				};

				const merge = (srcA, srcB) => {
					draw(mergeProgram, fbiTemp, {
						u_textureA: srcA.attachments[0],
						u_textureB: srcB.attachments[0],
					});

					draw(textureProgram, srcA, {
						u_texture: fbiTemp.attachments[0],
					});
					clearBuffer(fbiTemp);
				};

				// draw shapes
				if (shapes.length > 0) {
					draw(shapeProgram, fbiA, shapes[0]);
					for (let i = 1, n = shapes.length; i < n; ++i) {
						draw(shapeProgram, fbiB, shapes[i]);
						merge(fbiA, fbiB);
						clearBuffer(fbiB);
					}
				}

				// draw color
				draw(colorProgram, fbiD, {
					color: [1, 0.5, 1],
					maskTexture: fbiA.attachments[0],
				});
				//
				// clearBuffer(fbiA);

				// draw texture to canvas
				draw(textureProgram, null, {
					u_texture: fbiD.attachments[0],
				});
			}
			requestAnimationFrame(render);
		</script>
	</body>
</html>
